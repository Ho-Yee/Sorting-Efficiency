/*Austin Van Braeckel
20/11/2018

Displays a list of random numbers in the range from -10 000 to 10 000 inclusive.

User has the choice of:
- the number of random numbers to display (10, 100, 1000, or 5000)
- the order the numbers will be sorted in (ascending, descending)
- which algorithm they would like to see the numbers sorted by

Will sort the original unsorted numbers using the four following
sorting methods: selection sort, bubble sort, insertion sort, and quiksort.

Displays the number of times a loop was executed, as well as the actual time,
in milliseconds, that it took to complete each sort.

Performs the 4 sorts on the same set of data, so that the results are directly
comparable. 

A new set of random numbers is generated and displayed each time the 
user selects the ‘Sort Numbers’ button.
 */
package vanbraeckelsortingefficiency;

import java.util.Random;

public class GUI extends javax.swing.JFrame {

    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();

    }

    //Declare variables that need to be used across the GUI
    private static int numItems = 10; //Sets the default number of items to sort as 10
    private static boolean isAscending = true;
    private static int count;//used for counting the number of loop iterations for each sorting method

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        AorD = new javax.swing.ButtonGroup();
        amtNums = new javax.swing.ButtonGroup();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtSorted = new javax.swing.JTextArea();
        lblOriginal = new javax.swing.JLabel();
        lblSorted = new javax.swing.JLabel();
        lblResults = new javax.swing.JLabel();
        btnAscending = new javax.swing.JRadioButton();
        btnDescending = new javax.swing.JRadioButton();
        btnSort = new javax.swing.JButton();
        lblOrder = new javax.swing.JLabel();
        lblMethod = new javax.swing.JLabel();
        cbxMethod = new javax.swing.JComboBox<>();
        lblNums = new javax.swing.JLabel();
        rbt10 = new javax.swing.JRadioButton();
        rbt100 = new javax.swing.JRadioButton();
        rbt1000 = new javax.swing.JRadioButton();
        rbt5000 = new javax.swing.JRadioButton();
        lblTitle = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtOriginal = new javax.swing.JTextArea();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtResults = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sorting Efficiency - Austin Van Braeckel");
        setAlwaysOnTop(true);
        setResizable(false);

        txtSorted.setEditable(false);
        txtSorted.setColumns(15);
        txtSorted.setRows(10);
        jScrollPane2.setViewportView(txtSorted);

        lblOriginal.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblOriginal.setForeground(new java.awt.Color(51, 51, 51));
        lblOriginal.setText("Original Numbers:");

        lblSorted.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblSorted.setForeground(new java.awt.Color(51, 51, 51));
        lblSorted.setText("Sorted Numbers:");

        lblResults.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblResults.setForeground(new java.awt.Color(51, 51, 51));
        lblResults.setText("Sort Results:");

        AorD.add(btnAscending);
        btnAscending.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        btnAscending.setSelected(true);
        btnAscending.setText("Ascending");
        btnAscending.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAscendingActionPerformed(evt);
            }
        });

        AorD.add(btnDescending);
        btnDescending.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        btnDescending.setText("Descending");
        btnDescending.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDescendingActionPerformed(evt);
            }
        });

        btnSort.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        lblOrder.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblOrder.setForeground(new java.awt.Color(102, 102, 102));
        lblOrder.setText("Sort Order:");

        lblMethod.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblMethod.setForeground(new java.awt.Color(102, 102, 102));
        lblMethod.setText("Display numbers sorted by:");

        cbxMethod.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        cbxMethod.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Bubble Sort", "Selection Sort", "Insertion Sort", "Quick Sort" }));

        lblNums.setFont(new java.awt.Font("Trajan Pro", 1, 11)); // NOI18N
        lblNums.setForeground(new java.awt.Color(102, 102, 102));
        lblNums.setText("Amount of numbers to sort:");

        amtNums.add(rbt10);
        rbt10.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        rbt10.setSelected(true);
        rbt10.setText("10");
        rbt10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbt10ActionPerformed(evt);
            }
        });

        amtNums.add(rbt100);
        rbt100.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        rbt100.setText("100");
        rbt100.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbt100ActionPerformed(evt);
            }
        });

        amtNums.add(rbt1000);
        rbt1000.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        rbt1000.setText("1000");
        rbt1000.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbt1000ActionPerformed(evt);
            }
        });

        amtNums.add(rbt5000);
        rbt5000.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        rbt5000.setText("5000");
        rbt5000.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbt5000ActionPerformed(evt);
            }
        });

        lblTitle.setFont(new java.awt.Font("Westwood LET", 0, 48)); // NOI18N
        lblTitle.setText("Sorting Efficiency");

        txtOriginal.setEditable(false);
        txtOriginal.setColumns(15);
        txtOriginal.setRows(10);
        jScrollPane4.setViewportView(txtOriginal);

        txtResults.setEditable(false);
        txtResults.setColumns(21);
        txtResults.setRows(5);
        jScrollPane1.setViewportView(txtResults);

        jLabel1.setFont(new java.awt.Font("Trajan Pro", 0, 10)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(153, 153, 153));
        jLabel1.setText("Austin Van Braeckel, 2018");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 201, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 201, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(lblNums)
                        .addGap(18, 18, 18)
                        .addComponent(rbt10, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbt100, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbt1000, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbt5000, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addComponent(lblTitle))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(13, 13, 13)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(lblMethod)
                                .addGap(66, 66, 66)
                                .addComponent(cbxMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(lblOrder)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(btnDescending)
                                            .addComponent(btnAscending))
                                        .addGap(44, 44, 44))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(34, 34, 34)
                                        .addComponent(lblOriginal)
                                        .addGap(75, 75, 75)))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblSorted)
                                    .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(100, 100, 100)
                        .addComponent(lblResults)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 6, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(76, 76, 76))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 292, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(29, 29, 29)
                        .addComponent(lblResults)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 289, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel1)
                        .addGap(24, 24, 24))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addComponent(lblTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblNums)
                            .addComponent(rbt10)
                            .addComponent(rbt1000)
                            .addComponent(rbt100)
                            .addComponent(rbt5000))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblMethod)
                            .addComponent(cbxMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(btnAscending)
                                    .addComponent(lblOrder))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(btnDescending))
                            .addComponent(btnSort, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(21, 21, 21)
                                .addComponent(lblSorted))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(lblOriginal)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane4)
                            .addComponent(jScrollPane2))))
                .addGap(15, 15, 15))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void rbt100ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbt100ActionPerformed
        //Sets the number of items to 100
        numItems = 100;
    }//GEN-LAST:event_rbt100ActionPerformed

    /**
     * Sorts the given array using bubble sort (ascending) and returns a String
     * of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String bubbleSortA(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Bubble Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        //Set-up variables for the sort
        int j, temp;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                //Add one to the count of loop executions
                count++;
                if (arr[j] > arr[j + 1]) {
                    // swap arr[j] and arr[j+1] 
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            // If no two elements were swapped by inner loop, break 
            if (swapped == false) {
                break;
            }
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array using bubble sort (descending) and returns a String
     * of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String bubbleSortD(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Bubble Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        //Set-up variables for the sort
        int j, temp;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {

            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                //Add one to the count of loop executions
                count++;
                if (arr[j] < arr[j + 1]) {
                    //Swap arr[j] and arr[j+1] 
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            //If no two elements were swapped by inner loop, break 
            if (swapped == false) {
                break;
            }
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array using insertion sort (ascending) and returns a
     * String of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String insertionSortA(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Insertion Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;
            /* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */
            while (j >= 0 && arr[j] > key) {
                //Add one to the count of loop executions
                count++;
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array using insertion sort (descending) and returns a
     * String of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String insertionSortD(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Insertion Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;
            /* Move elements of arr[0..i-1], that are 
               greater than key, to one position ahead 
               of their current position */
            while (j >= 0 && arr[j] < key) {
                //Add one to the count of loop executions
                count++;
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array using selection sort (ascending) and returns a
     * String of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String selectionSortA(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Selection Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        // One by one move boundary of unsorted subarray 
        for (int i = 0; i < n - 1; i++) {

            // Find the minimum element in unsorted array 
            int min = i;
            for (int j = i + 1; j < n; j++) {
                //Add one to the count of loop executions
                count++;
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }

            // Swap the found minimum element with the first 
            // element 
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array using selection sort (descending) and returns a
     * String of the statistics
     *
     * @param arr that is to be sorted
     * @return String of statistics
     */
    public static String selectionSortD(int[] arr) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Selection Sort:\nNumber of times a loop was executed: ";
        //set-up variables to count how many times a loop is executed, and the time elapsed
        count = 0;
        long start = System.currentTimeMillis(), end; //begins tracking time
        int n = arr.length;
        // One by one move boundary of unsorted subarray 
        for (int i = 0; i < n - 1; i++) {

            // Find the minimum element in unsorted array 
            int min = i;
            for (int j = i + 1; j < n; j++) {
                //Add one to the count of loop executions
                count++;
                if (arr[j] > arr[min]) {
                    min = j;
                }
            }

            // Swap the found minimum element with the first 
            // element 
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
        end = System.currentTimeMillis(); //stops tracking time
        output += count + "\nTime Elapsed: " + (end - start);
        return output;
    }

    /**
     * Sorts the given array of integers in ascending order using quick sort
     *
     * @param arr Array to be sorted
     * @param low Starting index
     * @param high Ending index
     */
    public static String quickSortA(int arr[], int low, int high) {
        //Set up string to contain the statistics
        String output;
        if (low < high) {
            /* pi is partitioning index, arr[pi] is  
              now at the right place */
            int pi = partitionA(arr, low, high);

            // Recursively sort elements before 
            // partition and after partition 
            quickSortA(arr, low, pi - 1);
            quickSortA(arr, pi + 1, high);
        }
        output = "------------\n" + "Quick Sort:\nNumber of times a loop was executed: " + count;
        return output;
    }

    /**
     * Sorts the given array of integers in ascending order using quick sort
     *
     * @param arr Array to be sorted
     * @param low Starting index
     * @param high Ending index
     */
    public static String quickSortD(int arr[], int low, int high) {
        //Set up string to contain the statistics
        String output = "------------\n" + "Quick Sort:\nNumber of times a loop was executed: ";
        if (low < high) {
            /* pi is partitioning index, arr[pi] is  
              now at right place */
            int pi = partitionD(arr, low, high);
            // Recursively sort elements before 
            // partition and after partition 
            quickSortD(arr, low, pi - 1);
            quickSortD(arr, pi + 1, high);
        }
        output += count;
        return output;
    }

    /**
     * Takes last element as pivot, places the pivot element at its correct
     * (Ascending) position in sorted array, and places all smaller (smaller
     * than pivot) to left of pivot and all greater elements to right of pivot
     *
     * @param arr array of integers
     * @param low starting index
     * @param high ending index
     * @return
     */
    public static int partitionA(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1); // index of smaller element 
        for (int j = low; j < high; j++) {
            //Add one to the count of loop executions
            count++;

            //If current element is smaller than or equal to pivot 
            if (arr[j] <= pivot) {
                i++;
                //Swap arr[i] and arr[j] 
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        //Swap arr[i+1] and arr[high] (or pivot) 
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    /**
     * Takes last element as pivot, places the pivot element at its correct
     * (Ascending) position in sorted array, and places all smaller (smaller
     * than pivot) to left of pivot and all greater elements to right of pivot
     *
     * @param arr array of integers
     * @param low starting index
     * @param high ending index
     * @return
     */
    public static int partitionD(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1); // index of smaller element 
        for (int j = low; j < high; j++) {
            //Add one to the count of loop executions
            count++;

            //If current element is greater than or equal to pivot 
            if (arr[j] >= pivot) {
                i++;
                //Swap arr[i] and arr[j] 
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        //Swap arr[i+1] and arr[high] (or pivot) 
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    /**
     * Fills the given integer array with random numbers from -10000 to 10000
     * inclusive
     *
     * @param arr integer array that is to be filled
     * @return String of the array of the numbers
     */
    public static String randomNumberArray(int[] arr) {
        //Sets up random object for generating random numbers, and String for output
        Random r = new Random();
        String list = "";
        //Repeats for the whole array to be filled
        for (int i = 0; i < arr.length; i++) {
            //generate random number between -10000 and 10000 inclusive and puts it into array
            arr[i] = r.nextInt((10000 + 10000) + 1) - 10000; //((max - min) + 1) + min
            //Adds to the list of numbers
            if (i == 0) { //Makes sure the first line isn't skipped
                list += i + ": " + arr[i];
            } else {
                list += "\n" + i + ": " + arr[i];
            }
        }//end loop

        return list;
    }


    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed

        //Create an array to store the random numbers with the specified size (10 is default)
        int[] original = new int[numItems];
        /*Fill the array with random numbers and print the random numbers
       to the "original numbers" text area*/
        txtOriginal.setText(randomNumberArray(original));
        //Creates a copy of the array of random numbers for each sorting method
        int[] bubbleArr = original.clone();
        int[] selectionArr = original.clone();
        int[] insertionArr = original.clone();
        int[] quickArr = original.clone();
        //set-up final output String of the sorting statistics for the "Results" text area
        String results = "";
        //Determines if it is ascending or descending, and sorts the numbers with the different methods
        //Also adds their statistics to the output string for the "Results" text area
        if (isAscending) { //ascending order is selected
            results += bubbleSortA(bubbleArr);
            results += "\n" + selectionSortA(selectionArr);
            results += "\n" + insertionSortA(insertionArr);
            //set loop counter to 0, and determine time elapsed outside of the function since quick sort is recursive
            count = 0;
            long start = System.currentTimeMillis(), end; //begins tracking time
            results += "\n" + quickSortA(quickArr, 0, quickArr.length - 1);
            end = System.currentTimeMillis(); //stops tracking time
            results += "\nTime Elapsed: " + (end - start);
        } else { //descending order is selected
            results += bubbleSortD(bubbleArr);
            results += "\n" + selectionSortD(selectionArr);
            results += "\n" + insertionSortD(insertionArr);
            //set loop counter to 0, and determine time elapsed outside of the function since quick sort is recursive
            count = 0;
            long start = System.currentTimeMillis(), end; //begins tracking time
            results += "\n" + quickSortD(quickArr, 0, quickArr.length - 1);
            end = System.currentTimeMillis(); //stops tracking time
            results += "\nTime Elapsed: " + (end - start);
        }

        //display results to the user
        txtResults.setText(results);

        //initializes the array that will contain the selected sorting method's list of sorted numbers
        int[] sortedNumsArr = new int[numItems];
        //Determines which sorting method is selected
        String sortingMethod = cbxMethod.getSelectedItem().toString();
        //Set the display array to the one with the specified method
        if (sortingMethod.equals("Bubble Sort")) { //bubble sort
            sortedNumsArr = bubbleArr;
        } else if (sortingMethod.equals("Selection Sort")) { //selection sort
            sortedNumsArr = selectionArr;
        } else if (sortingMethod.equals("Insertion Sort")) { //insertion sort
            sortedNumsArr = insertionArr;
        } else { //quick sort
            sortedNumsArr = quickArr;
        }
        //Set-up output String and selected array for the "Sorted Numbers" text area
        String sortedNums = "";
        //Display the selected method's sorted number output in the text area
        for (int i = 0; i < sortedNumsArr.length; i++) { //repeats for the whole array and adds each number to a string
            if (i == 0) {//Checks if it is the first number, and only skips to the next line after the first
                sortedNums += i + ": " + sortedNumsArr[i];
            } else { //not the first number, so skips to next line for each entry
                sortedNums += "\n" + i + ": " + sortedNumsArr[i];
            }
        }//End for loop
        //Display the list in the "Sorted Numbers" text area
        txtSorted.setText(sortedNums);

    }//GEN-LAST:event_btnSortActionPerformed

    private void rbt10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbt10ActionPerformed
        //Sets number of items to 10
        numItems = 10;
    }//GEN-LAST:event_rbt10ActionPerformed

    private void rbt1000ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbt1000ActionPerformed
        //Sets number of items to 1000
        numItems = 1000;
    }//GEN-LAST:event_rbt1000ActionPerformed

    private void rbt5000ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbt5000ActionPerformed
        //Sets number of items to 5000
        numItems = 5000;
    }//GEN-LAST:event_rbt5000ActionPerformed

    private void btnAscendingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAscendingActionPerformed
        //Sets the arrays to ascending order
        isAscending = true;
    }//GEN-LAST:event_btnAscendingActionPerformed

    private void btnDescendingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDescendingActionPerformed
        //Sets all the arrays for descending order
        isAscending = false;
    }//GEN-LAST:event_btnDescendingActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup AorD;
    private javax.swing.ButtonGroup amtNums;
    private javax.swing.JRadioButton btnAscending;
    private javax.swing.JRadioButton btnDescending;
    private javax.swing.JButton btnSort;
    private javax.swing.JComboBox<String> cbxMethod;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JLabel lblMethod;
    private javax.swing.JLabel lblNums;
    private javax.swing.JLabel lblOrder;
    private javax.swing.JLabel lblOriginal;
    private javax.swing.JLabel lblResults;
    private javax.swing.JLabel lblSorted;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JRadioButton rbt10;
    private javax.swing.JRadioButton rbt100;
    private javax.swing.JRadioButton rbt1000;
    private javax.swing.JRadioButton rbt5000;
    private javax.swing.JTextArea txtOriginal;
    private javax.swing.JTextArea txtResults;
    private javax.swing.JTextArea txtSorted;
    // End of variables declaration//GEN-END:variables
}
